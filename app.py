#!/usr/bin/env python3
# thoth-cve-update-producer
# Copyright(C) 2020-2021 Fridolin Pokorny, Bissenbay Dauletbayev
#
# This program is free software: you can redistribute it and / or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""Update Thoth's database of CVEs."""

import logging
import os
from datetime import datetime
from typing import Any
from typing import Dict
from typing import Optional
from urllib.parse import urlparse

import click
import yaml
import tempfile
from git import Repo

from prometheus_client import CollectorRegistry, Gauge, Counter, push_to_gateway

from thoth.common import init_logging
from thoth.common import __version__ as __common__version__
from thoth.common import datetime2datetime_str
from thoth.messaging.cve_provided import cve_provided_message
from thoth.messaging.cve_provided import MessageContents as CVEProvidedMessageContent
from thoth.messaging import __version__ as __messaging__version__
from thoth.messaging.producer import create_producer, publish_to_topic
from thoth.storages import GraphDatabase
from thoth.storages import __version__ as __storages__version__

__version__ = "0.5.4"
__component_version__ = (
    f"{__version__}+storages.{__storages__version__}"
    f".common.{__common__version__}"
    f".messaging.{__messaging__version__}"
)

prometheus_registry = CollectorRegistry()
THOTH_DEPLOYMENT_NAME = os.getenv("THOTH_DEPLOYMENT_NAME")
_THOTH_METRICS_PUSHGATEWAY_URL = os.getenv("PROMETHEUS_PUSHGATEWAY_URL")

_PRODUCER = create_producer()
_COMPONENT_NAME = "thoth-cve-update-job"

_GRAPH_DB = GraphDatabase()
_GRAPH_DB.connect()

init_logging()

_LOGGER = logging.getLogger("thoth.cve_update")
_LOGGER.info(f"Thoth-cve-update-producer v{__component_version__}")


# Metrics Exporter Metrics
_METRIC_INFO = Gauge(
    "thoth_cve_update_job_info",
    "Thoth CVE update Producer information",
    ["env", "version"],
    registry=prometheus_registry,
)

_METRIC_MESSSAGES_SENT = Counter(
    "thoth_cve_update_job_messages_sent",
    "Thoth CVE update Producer information sent",
    ["message_type", "env", "version"],
    registry=prometheus_registry,
)

_METRIC_DATABASE_SCHEMA_SCRIPT = Gauge(
    "thoth_database_schema_revision_script",
    "Thoth database schema revision from script",
    ["component", "revision", "env"],
    registry=prometheus_registry,
)

_METRIC_INFO.labels(THOTH_DEPLOYMENT_NAME, __component_version__).inc()
_METRIC_DATABASE_SCHEMA_SCRIPT.labels(
    _COMPONENT_NAME, _GRAPH_DB.get_script_alembic_version_head(), THOTH_DEPLOYMENT_NAME
).inc()


def _get_vulnerability_link(vulnerability: Dict[str, Any]) -> Optional[str]:
    """Retrieve a link to vulnerability for users."""
    link: Optional[str] = None
    for reference in vulnerability.get("references") or []:
        if reference.get("type") != "WEB":
            _LOGGER.debug("Skipping reference %r: not a WEB reference", reference)
            continue

        if "redhat" in urlparse(reference["url"]).netloc:
            # Get first reference to a Red Hat bugzilla or a similar Red Hat source.
            return reference["url"]

        if link is None:
            link = reference["url"]

    return link


def _record_vulnerability(
    graph: GraphDatabase, vulnerability: Dict[str, Any], cve_messages_sent: int
) -> int:
    """Record the given vulnerability in the database."""
    _LOGGER.info("Creating CVE entries for %r...", vulnerability["id"])

    cve_id = vulnerability["id"]
    for affected in vulnerability.get("affected") or []:
        if affected["package"]["ecosystem"] != "PyPI":
            _LOGGER.info(
                "Skipping affected package %r from ecosystem %r",
                affected["package"]["name"],
                affected["package"]["ecosystem"],
            )
            continue

        package_name = affected["package"]["name"]

        for package_version in affected.get("versions") or []:
            existed = graph.create_python_cve_record(
                package_name,
                package_version,
                "https://pypi.org/simple",
                cve_id=cve_id,
                details=vulnerability["details"],
                link=_get_vulnerability_link(vulnerability),
            )

            if existed:
                continue

            _LOGGER.info(
                "Created new CVE %r entry for package %r in version %r",
                cve_id,
                package_name,
                package_version,
            )

            publish_to_topic(
                _PRODUCER,
                cve_provided_message,
                CVEProvidedMessageContent(
                    component_name=_COMPONENT_NAME,
                    service_version=__component_version__,
                    package_name=package_name,
                    package_version=package_version,
                    index_url="https://pypi.org/simple",
                ),
            )

            cve_messages_sent += 1

    return cve_messages_sent


@click.command()
@click.option(
    "--advisory-db",
    help="URL to advisory database.",
    default="https://github.com/pypa/advisory-db.git",
    metavar="URL.git",
    envvar="THOTH_CVE_UPDATE_ADVISORY_REPO",
    show_default=True,
)
def cli(advisory_db: str) -> None:
    """Aggregate CVE information and store it in Thoth's database."""
    cve_timestamp = datetime.utcnow()

    with tempfile.TemporaryDirectory() as repo_dir:
        Repo.clone_from(advisory_db, repo_dir, depth=1)
        vulnerabilities_dir = os.path.join(repo_dir, "vulns")
        cve_messages_sent = 0
        for package_name in os.listdir(os.path.join(vulnerabilities_dir)):
            if package_name.startswith("."):
                continue

            _LOGGER.info("Parsing vulnerabilities for %r", package_name)

            for vulnerability_file in os.listdir(
                os.path.join(vulnerabilities_dir, package_name)
            ):
                _LOGGER.info("Loading vulnerability file %r", vulnerability_file)
                vulnerability_file_path = os.path.join(
                    vulnerabilities_dir, package_name, vulnerability_file
                )
                try:
                    with open(vulnerability_file_path) as f:
                        vulnerability_file_content = yaml.safe_load(f)
                except Exception:
                    _LOGGER.exception(
                        "Failed to parse vulnerability file %r, skipping...",
                        vulnerability_file_path,
                    )
                else:
                    try:
                        cve_messages_sent += _record_vulnerability(
                            _GRAPH_DB, vulnerability_file_content, cve_messages_sent
                        )
                    except Exception:
                        _LOGGER.exception(
                            "Failed to record vulnerability from file %r, skipping..",
                            vulnerability_file_path,
                        )

            _METRIC_MESSSAGES_SENT.labels(
                message_type=cve_provided_message.topic_name,
                env=THOTH_DEPLOYMENT_NAME,
                version=__component_version__,
            ).inc(cve_messages_sent)

            if _THOTH_METRICS_PUSHGATEWAY_URL:
                try:
                    _LOGGER.debug(
                        "Submitting metrics to Prometheus pushgateway %s",
                        _THOTH_METRICS_PUSHGATEWAY_URL,
                    )
                    push_to_gateway(
                        _THOTH_METRICS_PUSHGATEWAY_URL,
                        job="cve-update",
                        registry=prometheus_registry,
                    )
                except Exception as e:
                    _LOGGER.exception(
                        f"An error occurred pushing the metrics: {str(e)}"
                    )

    _LOGGER.info("Flushing pending messages")
    _PRODUCER.flush()
    _LOGGER.info("Setting CVE timestamp to %r", datetime2datetime_str(cve_timestamp))
    _GRAPH_DB.set_cve_timestamp(cve_timestamp)


__name__ == "__main__" and cli()
